{
	"math": {
			"prefix": "math",
			"body": [

"struct math",
"{",
"private:",
"   bool check_prime(ll a, ll d, ll s, ll n)",
"   {",
"      ll x = modular_exponential(a, d, n);",
"      if (x == 1 || x == n - 1)",
"         return true; ",
"",
"      for (int i = 1; i < s; ++i)",
"      {",
"         x = get_mul(x, x, n);",
"         if (x == n - 1)",
"            return true;",
"      }",
"",
"      return false;",
"   }",
"",
"public:",
"   math() {}",
"   // cmp double",
"   int dcmp(double x, double y)",
"   {",
"      return (fabs(x - y) <= EPS ? 0 : (x < y ? -1 : 1));",
"   }",
"",
"   ll summation(ll first, ll last)",
"   {",
"      ll x = last - first + 1;",
"      return ((first + last) * x) / 2;",
"   }",
"",
"   // get kth element in sequence increase by multiple of constant",
"   // 1 4 16...",
"   // 1 3 9...",
"   ll kth(ll first, ll ratio, ll k)",
"   {",
"      // ratio->the constant number",
"      return first * pow(ratio, k - 1);",
"   }",
"",
"   // get ow many number between A & B Divisible by M",
"   ll CountDivisibles(ll A, ll B, ll M)",
"   {",
"      if (A % M == 0)",
"         return (B / M) - (A / M) + 1;",
"",
"      return (B / M) - (A / M);",
"   }",
"",
"   // get summation of geometry sequence increase by multiple of constant",
"   // 1 4 16...",
"   // 1 3 9...",
"   ll geometry_summation(ll first, ll ratio, int number_of_element)",
"   {",
"      return ((first * (1 - pow(ratio, number_of_element))) / (1 - ratio));",
"   }",
"",
"   // get num of odd numbers between l & r",
"   ll num_of_odd(ll l, ll r)",
"   {",
"      return (r - l + 1) - (r / 2 - (l - 1) / 2);",
"   }",
"",
"   ll get_mul(ll a, ll b, ll mod = 1000000007)",
"   {",
"      ll res = 0;",
"",
"      while (b)",
"      {",
"         if (b & 1)",
"         res = (res + a) % mod;",
"         a = (a * 2) % mod;",
"         b >>= 1;",
"      }",
"",
"      return res % mod;",
"   }",
"",
"   ll binary_exponential(ll a, ll b)",
"   {",
"      ll res = 1;",
"",
"      while (b)",
"      {",
"         if (b & 1)",
"         res *= a;",
"         a *= a;",
"         b >>= 1;",
"      }",
"",
"      return res;",
"   }",
"",
"   ll modular_exponential(ll a, ll b, ll mod = 1000000007)",
"   {",
"      ll res = 1;",
"",
"      while (b)",
"      {",
"         if (b & 1)",
"         res = (res * a) % mod;",
"         a = (a * a) % mod;",
"         b >>= 1;",
"      }",
"",
"      return res % mod;",
"   }",
"   ll mod_inv(ll x)",
"   {",
"      return modular_exponential(x, MOD - 2);",
"   }",
"",
"   vector<ll> divisors(ll n)",
"   {",
"      vector<ll> ans;",
"",
"      for (int i = 1; i * i <= n; ++i)",
"      {",
"         if (n % i == 0)",
"         {",
"            ans.eb(i);",
"            if (i != n / i)",
"               ans.eb(n / i);",
"         }",
"      }",
"",
"      sort(all(ans));",
"",
"      return ans;",
"   }",
"",
"   vector<pair<ll, ll>> prime_factorization(ll n)",
"   {",
"      vector<pair<ll, ll>> ans;",
"",
"      ll cnt = 0;",
"",
"      while (n % 2 == 0)",
"         cnt++, n /= 2;",
"",
"      if (cnt > 0)",
"         ans.pb({2, cnt});",
"",
"      for (int i = 3; i * i <= n; i += 2)",
"      {",
"         cnt = 0;",
"         if (n % i == 0)",
"         {",
"            while (n % i == 0)",
"               cnt++, n /= i;",
"",
"            ans.pb({i, cnt});",
"         }",
"      }",
"",
"      if (n != 1)",
"         ans.pb({n, 1});",
"",
"      return ans;",
"   }",
"",
"   ll GCD(ll a, ll b)",
"   {",
"      return (!b ? a : GCD(b, a % b));",
"   }",
"",
"   ll LCM(ll a, ll b)",
"   {",
"      return a / GCD(a, b) * b;",
"   }",
"",
"   int Extended_Euclidean(int a, int b, int &x, int &y)",
"   {",
"      if (b == 0)",
"      {",
"         x = 1;",
"         y = 0;",
"         return a;",
"      }",
"",
"      int x1, y1;",
"      int d = Extended_Euclidean(b, a % b, x1, y1);",
"      x = y1;",
"      y = x1 - y1 * (a / b);",
"      return d;",
"   }",
"",
"   int reverse_summation(ll n)",
"   {",
"      ll a = (-1 + (ll)sqrtl(1 + 8 * n)) / 2;",
"      ll z = summation(1, a);",
"      return (n == z ? a : -1);",
"   }",
"",
"   // if p is prime number then (a^(p-1))%p==1",
"   // a is a random number in range 0<a<p",
"",
"   bool Fermat_Primality_Testing(ll p, ll k) // will take k random number to check",
"   {",
"      if (p <= 4)",
"         return (p == 2 || p == 3);",
"      for (int i = 0; i < k; ++i)",
"      {",
"         ll y = (rand() % ((p - 2) - 2 + 1)) + 2; // will make rand function get random value in range 2 to p-2",
"         ll x = modular_exponential(y, p - 1, p);",
"         if (x != 1)",
"            return false;",
"      }",
"      return true;",
"   }",
"",
"   // check if n is prime (even n is a big number)",
"   // rand^d%n==1",
"   // rand^((2^s)*d)%n==1",
"   bool Miller_Rabin(ll n, ll step = 1000)",
"   {",
"      if (n <= 4)",
"         return n == 2 || n == 3;",
"",
"      ll d = n - 1;",
"      ll s = 0;",
"      while (!(d & 1))",
"      {",
"         d >>= 1;",
"         s++;",
"      }",
"",
"      for (int i = 1; i <= step; ++i)",
"      {",
"         ll a = (rand() % ((n - 2) - 2 + 1)) + 2;",
"         if (!check_prime(a, d, s, n))",
"            return false;",
"      }",
"",
"      return true;",
"   }",
"",
"   // Euler Totient = phi(a)",
"   // get how many numbers less than n with gcd =1 with n",
"   // a = p1^a * p2^b * p3^c * .... -> prime factorization",
"   // phi(a) = phi(p1^a) * phi(p2^b) * phi(p3^c) * ....",
"   // phi(p^a)= p^a - p^(a-1)",
"   // phi(a) = (p1^a - p1^(a-1)) * (p2^b - p2^(b-1)) * (p3^c - p3^(c-1)) * ....",
"   // phi(a) = p1^a * (1 - p1^(-1)) * p2^b * (1 - p2^(-1)) * p3^c * (1 - p3^(-1)) * ....",
"   // phi(a) = p1^a * p2^b * p3^c * ..... * (1 - p1^(-1)) * (1 - p2^(-1)) * (1 - p3^(-1)) * ....",
"   // phi(a) = a * (1 - p1^(-1)) * (1 - p2^(-1)) * (1 - p3^(-1)) * ....",
"",
"   // Time Complexity O(sqrt(n))",
"",
"   ll phi(ll a)",
"   {",
"      vector<pair<ll, ll>> vec = prime_factorization(a);",
"      double ans = a;",
"      for (auto &[l, r] : vec)",
"         ans *= (1.0 - (1.0 / double(l)));",
"",
"      return (ll)ans;",
"   }",
"",
"   // Time Complexity O(n*log(log(n)))",
"",
"   vector<int> phi_0_to_n(int n)",
"   {",
"      vector<int> phi(n + 1);",
"      for (int i = 0; i <= n; i++)",
"         phi[i] = i;",
"",
"      for (int i = 2; i <= n; i++)",
"      {",
"         if (phi[i] == i)",
"         {",
"            for (int j = i; j <= n; j += i)",
"               phi[j] -= phi[j] / i;",
"         }",
"      }",
"",
"      return phi;",
"   }",
"   // get summation for sequence that increases in a constant number",
"   // 2 4 6 ....",
"   // 1 4 7 ....",
"   ll arithmetic_progression(ll n, ll a, ll d)",
"   {",
"      // n->is the number of terms in the series",
"      // a->is the first term of the series",
"      // d->is the common difference between the terms",
"      int last = last_term_in_arithmetic_progression(n, a, d);",
"      return n * (a + last) / 2;",
"   }",
"",
"   ll last_term_in_arithmetic_progression(ll n, ll a, ll d)",
"   {",
"      return a + (n - 1) * d;",
"   }",
"",
"   // get double distance between two points",
"   double Euclidean_Distance(int x1, int y1, int x2, int y2)",
"   {",
"      double x = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));",
"      return x;",
"   }",
"",
"   ll num_of_divisors(ll n)",
"   {",
"      ll div = 0;",
"",
"      for (int i = 1; i * i <= n; ++i)",
"      {",
"         if (n % i == 0)",
"         {",
"            div++;",
"            if (i != n / i)",
"               div++;",
"         }",
"      }",
"",
"      return div;",
"   }",
"",
"   double slope(double x1, double y1, double x2, double y2)",
"   {",
"      if (x1 - x2 == 0)",
"         return -OO;",
"",
"      return (y2 - y1) / (x2 - x1);",
"   }",
"",
"   bool is_prime(ll n)",
"   {",
"      if (n < 2 || (!(n & 1) && n != 2))",
"         return false;",
"      for (int i = 3; i*i <= n; i += 2)",
"         if (n % i == 0)",
"            return false;",
"      return true;",
"   }",
"",
"   ll nCr(ll n, ll r)",
"   {",
"      if (r > n)",
"         return 0;",
"      ll p = 1, k = 1;",
"      if (n - r < r)",
"         r = n - r;",
"      if (n < 1)",
"         return 0;",
"      while (r > 0)",
"      {",
"         p *= n, k *= r;",
"         ll m = __gcd(p, k);",
"         p /= m, k /= m, n--, r--;",
"      }",
"      return p;",
"   }",
"",
"   ll nPr(ll n, ll r)",
"   {",
"      if (r > n)",
"         return 0;",
"      ll npr = 1;",
"      while (r-- > 0)",
"        npr *= n--;",
"      return npr;",
"   }",
"",
"   ll Summation_of_Devisors(ll a, ll b, ll c){",
"      ll right = summation(1, b / c);",
"      ll left = summation(1, (a - 1) / c);",
"      return (right - left) * c;",
"   }",
"};",
            ],
            "description": "Log output to console"
	}

	"kadane1dmx": {
	"prefix": "kadane1dmx",
	"body": [
"// Maximum Subarray Sum with dimensions",
"// Time Complexity O(N)",
"vector<ll> max_Kadane(ll n, vector<ll> &vec)",
"{",
"    vector<ll> ans(3, -OO);",
"    ll sum = 0, l = 0, r = 0;",
"    for (int i = 0; i < n; ++i)",
"    {",
"        sum += vec[i];",
"        if (ans[0] < sum)",
"        {",
"            ans[0] = sum;",
"            ans[1] = l;",
"            ans[2] = r;",
"        }",
"",
"        r++;",
"",
"        if (sum < 0)",
"        {",
"            sum = 0;",
"            l = r;",
"        }",
"    }",
"",
"    return ans;",
"}",
	],
	"description": "Log output to console"
	}

    "kadane1dmn": {
    "prefix": "kadane1dmn",
    "body": [
"// minimum Subarray Sum with dimensions",
"// Time Complexity O(N)",
"vector<ll> min_Kadane(ll n, vector<ll> &vec)",
"{",
"    vector<ll> ans(3, OO);",
"    ll sum = 0, l = 0, r = 0;",
"    for (int i = 0; i < n; ++i)",
"    {",
"        sum += vec[i];",
"        if (ans[0] > sum)",
"        {",
"            ans[0] = sum;",
"            ans[1] = l;",
"            ans[2] = r;",
"        }",
"",
"        r++;",
"",
"        if (sum > 0)",
"        {",
"            sum = 0;",
"            l = r;",
"        }",
"    }",
"    return ans;",
"",
"}",
    ],
    "description": "Log output to console"
    }


    "kadane2dmx": {
        "prefix": "kadane2dmx",
        "body": [
"vector<ll> max_Kadane(ll n, vector<ll> &vec)",
"{",
"    vector<ll> ans(3, -OO);",
"    ll sum = 0, l = 0, r = 0;",
"    for (int i = 0; i < n; ++i)",
"    {",
"        sum += vec[i];",
"        if (ans[0] < sum)",
"        {",
"            ans[0] = sum;",
"            ans[1] = l;",
"            ans[2] = r;",
"        }",
"",
"        r++;",
"",
"        if (sum < 0)",
"        {",
"            sum = 0;",
"            l = r;",
"        }",
"",
"    }",
"",
"    return ans;",
"",
"}",
"",
"vector<ll> max_2dKadane(ll n, ll m, vector<vector<ll>> &vec)",
"{",
"    ll bottom = 0, top = 0, left = 0, right = 0, max_sum = -OO;",
"    for (int l = 0; l < m; ++l)",
"    {",
"        vector<ll> v(n);",
"        for (int r = l; r < m; ++r)",
"        {",
"            for (int i = 0; i < n; ++i)",
"                v[i] += vec[i][r];",
"            vector<ll> mx = max_Kadane(n, v);",
"            if (max_sum < mx[0])",
"            {",
"                max_sum = mx[0];",
"                top = mx[1];",
"                bottom = mx[2];",
"                left = l;",
"                right = r;",
"            }",
"        }",
"    }",
"",
"    vector<ll> ans = {max_sum, top + 1, bottom + 1, left + 1, right + 1};",
"",
"    return ans;",
"",
"}",
    ],
    "description": "Log output to console"
    }



    "kadane2dmn": {
        "prefix": "kadane2dmn",
        "body": [
"vector<ll> min_Kadane(ll n, vector<ll> &vec)",
"{",
"    vector<ll> ans(3, OO);",
"    ll sum = 0, l = 0, r = 0;",
"    for (int i = 0; i < n; ++i)",
"    {",
"        sum += vec[i];",
"        if (ans[0] > sum)",
"        {",
"            ans[0] = sum;",
"            ans[1] = l;",
"            ans[2] = r;",
"        }",
"",
"        r++;",
"",
"        if (sum > 0)",
"        {",
"            sum = 0;",
"            l = r;",
"        }",
"",
"    }",
"",
"    return ans;",
"}",
"",
"vector<ll> min_2dKadane(ll n, ll m, vector<vector<ll>> &vec)",
"{",
"    ll bottom = 0, top = 0, left = 0, right = 0, min_sum = OO;",
"    for (int l = 0; l < m; ++l)",
"    {",
"        vector<ll> v(n);",
"        for (int r = l; r < m; ++r)",
"        {",
"            for (int i = 0; i < n; ++i)",
"                v[i] += vec[i][r];",
"            vector<ll> mn = min_Kadane(n, v);",
"            if (min_sum > mn[0])",
"            {",
"                min_sum = mn[0];",
"                top = mn[1];",
"                bottom = mn[2];",
"                left = l;",
"                right = r;",
"            }",
"        }",
"    }",
"",
"    vector<ll> ans = {min_sum, top + 1, bottom + 1, left + 1, right + 1};",
"",
"    return ans;",
"",
"}",
    ],
    "description": "Log output to console"
    }

    "bellmanFord": {
        "prefix": "bellmanFord",
        "body": [
"struct edge",
"{",
"    int src, dst, w;",
"    edge(int _src, int _dst, int _w) : src(_src), dst(_dst), w(_w) {}",
"    bool operator<(const edge &rhs) const",
"    {",
"        return w > rhs.w;",
"    }",
"};",
"",
"struct bellmanFord",
"{",
"    vector<int> par, val;",
"    vector<edge> graph;",
"    int v, e, start, end;",
"    bool n_cycle, bulid;",
"",
"    bellmanFord(int n, vector<edge> &vec, int start, int end = -1) : start(start), end(end)",
"    {",
"        bulid = 1;",
"        n_cycle = false;",
"        v = n;",
"        e = sz(vec);",
"        graph = vec;",
"        par.assign(v + 5, -1);",
"        val.assign(v + 5, OO);",
"    }",
"",
"    vector<int> bellman()",
"    {",
"        bulid = 1;",
"        par[start] = -1;",
"        val[start] = 0;",
"",
"        for (int i = 0; i < v - 1; ++i)",
"        {",
"            bool update = false;",
"            for (int l = 0; l < e; ++l)",
"            {",
"                int a, b, wt;",
"                a = graph[l].src;",
"                b = graph[l].dst;",
"                wt = graph[l].w;",
"",
"                if (val[a] != OO && val[a] + wt < val[b])",
"                {",
"                    update = true;",
"                    val[b] = val[a] + wt;",
"                    par[b] = a;",
"                }",
"",
"            }",
"",
"            if (!update)",
"                break;",
"",
"        }",
"",
"        for (int l = 0; l < e; ++l)",
"        {",
"            int a, b, wt;",
"            a = graph[l].src;",
"            b = graph[l].dst;",
"            wt = graph[l].w;",
"",
"            if (val[a] != OO && val[a] + wt < val[b])",
"            {",
"                // -N cycle",
"                n_cycle = 1;",
"                return {-1};",
"            }",
"",
"        }",
"",
"        return val;",
"",
"    }",
"",
"    vector<int> get_path(int src, int dst)",
"    {",
"        start = src;",
"        end = dst;",
"",
"        if (!bulid)",
"            bellman();",
"",
"        if (n_cycle)",
"            return {-1};",
"",
"        vector<int> ans;",
"",
"        for (int i = end; i != -1; i = par[i])",
"            ans.eb(i);",
"",
"        reverse(all(ans));",
"        return ans;",
"    }",
"};",
        ],
        "description": "Log output to console"
    }



    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
"// Dijkstra_algorithm with connected graph",
"// Time Complexity n log(n)",
"vector<ll> Dijkstra(ll start, vector<vector<pair<ll, ll>>> &graph)",
"{",
"    int sz = sz(graph);",
"    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;",
"    vector<ll> dis(sz, OO);",
"    pq.push({0, start});",
"    dis[start] = 0;",
"",
"    while (!pq.empty())",
"    {",
"        auto [Dis, node] = pq.top();",
"        pq.pop();",
"        if (Dis != dis[node])",
"            continue;",
"        for (auto &[ch, Distance] : graph[node])",
"        {",
"            if (Dis + Distance < dis[ch])",
"            {",
"                dis[ch] = Dis + Distance;",
"                pq.push({dis[ch], ch});",
"            }",
"        }",
"    }",
"",
"    return dis;",
"}",
        ],
        "description": "Log output to console"
    }



    "floyd": {
        "prefix": "floyd",
        "body": [
"template <typename T = int, int base = 1>",
"struct floyd",
"{",
"    struct Graph",
"    {",
"        T u, v, w;",
"        Graph(T _u = 0, T _v = 0, T _w = 0) : u(_u), v(_v), w(_w){};",
"        bool operator<(const T &rhs)",
"        {",
"            return w < rhs.w;",
"        }",
"    };",
"",
"    T n;",
"    vector<Graph> graph;",
"    vector<vector<T>> dis;",
"",
"    floyd(T n, T e)",
"    {",
"        this->n = n;",
"        graph.resize(e);",
"        dis.assign(n + 5, vector<T>(n + 5, OO));",
"    }",
"",
"    floyd(T n, T e, vector<vector<int>> &vec)",
"    {",
"        this->n = n;",
"        graph.resize(e);",
"        dis.assign(n + 5, vector<T>(n + 5, OO));",
"        for (int i = 0; i < e; ++i)",
"        {",
"            graph[i].u = vec[i][0];",
"            graph[i].v = vec[i][1];",
"            graph[i].w = vec[i][2];",
"            dis[graph[i].u][graph[i].u] = dis[graph[i].v][graph[i].v] = 0;",
"            dis[graph[i].u][graph[i].v] = dis[graph[i].v][graph[i].u] = min({dis[graph[i].u][graph[i].v], dis[graph[i].v][graph[i].u], graph[i].w});",
"        }",
"    }",
"",
"    vector<vector<T>> put_input()",
"    {",
"        for (auto &i : graph)",
"        {",
"            cin >> i.u >> i.v >> i.w;",
"            dis[i.u][i.u] = dis[i.v][i.v] = 0;",
"            dis[i.u][i.v] = dis[i.v][i.u] = min({dis[i.u][i.v], dis[i.v][i.u], i.w});",
"        }",
"        return Floyd();",
"    }",
"",
"    T operation(T a, T b, T c)",
"    {",
"        return min(a, b + c);",
"    }",
"",
"    vector<vector<T>> Floyd()",
"    {",
"        for (int node = base; node < n + base; ++node)",
"            for (int u = base; u < n + base; ++u)",
"                for (int v = base; v < n + base; ++v)",
"                    dis[u][v] = operation(dis[u][v], dis[u][node], dis[node][v]);",
"        return dis;",
"    }",
"",
"};",
        ],
        "description": "Log output to console"
    }



    "Isomorphism": {
        "prefix": "Isomorphism",
        "body": [
"struct Isomorphism",
"{",
"private:",
"    string dfs(int node, vector<vector<string>> &can)",
"    {",
"        string ans = "(";",
"        sort(all(can[node]));",
"".
"        for (auto &i : can[node])",
"            ans += i;",
"",
"        ans += ')';",
"        return ans;",
"    }",
"public:",
"    Isomorphism() {}",
"    // when compare between two trees with given the root",
"    string dfs(int node, int par, vector<vector<int>> &graph)",
"    {",
"        vector<string> ans;",
"        for (auto &ch : graph[node])",
"            if (ch != par)",
"                ans.pb(dfs(ch, node, graph));",
"",
"        string s = "(";",
"        sort(all(ans));",
"",
"        for (auto &l : ans)",
"            s += l;",
"",
"        s += ')';",
"        return s;",
"    }",
"",
"    // when compare between two trees without given the root",
"    string bfs(ll n, vector<vector<int>> &graph)",
"    {",
"        queue<int> leaf;",
"        vector<int> deg(n + 5, 0);",
"        vector<vector<string>> can(n + 5);",
"        for (int i = 1; i <= n; ++i)",
"        {",
"            if (sz(graph[i]) <= 1)",
"                leaf.push(i);",
"            else",
"                deg[i] = sz(graph[i]);",
"        }",
"",
"        int cnt_node = n;",
"        while (cnt_node > 2)",
"        {",
"            int sz = sz(leaf);",
"            while (sz--)",
"            {",
"                int x = leaf.front();",
"                leaf.pop();",
"                string s = dfs(x, can);",
"                for (auto &par : graph[x])",
"                {",
"                    can[par].push_back(s);",
"                    if (--deg[par] == 1)",
"                        leaf.push(par);",
"                }",
"                cnt_node--;",
"            }",
"        }",
"",
"        int node1 = leaf.front();",
"        leaf.pop();",
"        string ans1 = dfs(node1, can);",
"",
"        if (leaf.empty())",
"            return ans1;",
"",
"        int node2 = leaf.front();",
"        leaf.pop();",
"        string ans2 = dfs(node2, can);",
"        can[node1].push_back(ans2);",
"        can[node2].push_back(ans1);",
"        return min(dfs(node1, can), dfs(node2, can));",
"    }",
"};",
        ],
        "description": "Log output to console"
    }


    "minimum_spanning_tree": {
        "prefix": "minimum_spanning_tree",
        "body": [
"// Time complexity (v^2)",
"template <typename T = int>",
"struct prim",
"{",
"    int sz;",
"    vector<vector<T>> graph; // adj matrix",
"    vector<int> vis, par;",
"    vector<T> val;",
"    prim(vector<vector<T>> &_graph, int n) : graph(_graph)",
"    {",
"        sz = n;",
"        vis.assign(n, 0);",
"        par.assign(n, 0);",
"        val.assign(n, OO);",
"    }",
"",
"    int min_val()",
"    {",
"        T mn = OO;",
"        int v;",
"        for (int i = 0; i < sz; ++i)",
"        {",
"            if (!vis[i] && val[i] < mn)",
"            {",
"                mn = val[i];",
"                v = i;",
"            }",
"        }",
"        return v;",
"    }",
"",
"    vector<T> Prim()",
"    {",
"        val[0] = 0;",
"        par[0] = -1;",
"        for (int i = 0; i < sz - 1; ++i)",
"        {",
"            int v = min_val();",
"            vis[v] = 1;",
"            for (int l = 0; l < sz; ++l)",
"            {",
"                if (!vis[l] && graph[v][l] && val[l] > graph[v][l])",
"                {",
"                    val[l] = graph[v][l];",
"                    par[l] = v;",
"                }",
"            }",
"        }",
"",
"        return val;",
"    }",
"};",
        ],
        "description": "Log output to console"
    }


    "tree_Diameter": {
        "prefix": "tree_Diameter",
        "body": [
// start from any node for example this node will be (a)
"// get the farthest node from (a) and this node will be (b)",
"// get the farthest node from (b) and this node will be (c)",
"// distance from node b to node c will be the length of the tree_Diameter",
"struct tree_Diameter",
"{",
"    int n;",
"    vector<vector<int>> graph;",
"    vector<int> par;",
"    int start_node, last_node;",
"",
"    tree_Diameter(int _n, vector<vector<int>> &_graph, int node = 1) : n(_n), graph(_graph), start_node(node)",
"    {",
"        par.assign(n + 1, -1);",
"        int dis = 0;",
"        queue<pair<int, int>> q;",
"        vector<int> vis(n + 5);",
"        q.push({start_node, 0});",
"",
"        while (!q.empty())",
"        {",
"            // auto [par, dis_par]",
"            pair<int, int> pr = q.front();",
"            q.pop();",
"            vis[pr.fi]++;",
"            if (pr.se > dis)",
"                dis = pr.se, start_node = pr.fi;",
"            for (auto &child : graph[pr.fi])",
"            {",
"                if (!vis[child])",
"                    q.push({child, pr.se + 1});",
"            }",
"        }",
"",
"    };",
"",
"    int get_distance()",
"    {",
"        int dis = 0;",
"        queue<pair<int, int>> q;",
"        vector<int> vis(n + 5);",
"        q.push({start_node, 0});",
"",
"        while (!q.empty())",
"        {",
"            pair<int, int> pr = q.front();",
"            q.pop();",
"            vis[pr.fi]++;",
"            if (pr.se > dis)",
"                dis = pr.se, last_node = pr.fi;",
"",
"            for (auto &child : graph[pr.fi])",
"            {",
"                if (!vis[child])",
"                    q.push({child, pr.se + 1}), par[child] = pr.fi;",
"            }",
"",
"        }",
"",
"        return dis;",
"    }",
"",
"    vector<int> get_tree_Diameter()",
"    {",
"        get_distance();",
"        vector<int> ans;",
"        for (int i = last_node; i != -1; i = par[i])",
"            ans.eb(i);",
"",
"        return ans;",
"    }",
"};",
        ],
        "description": "Log output to console"
    }


    "ternary_search_FindKey": {
        "prefix": "ternary_search_FindKey",
        "body": [
"ll ternary_search(vector<ll> &vec, ll l, ll r, ll key)",
"{",
"    if (l <= r)",
"    {",
"        int mid1 = l + (r - l) / 3, mid2 = r - (r - l) / 3;",
"        if (vec[mid1] == key)",
"            return mid1;",
"",
"        if (vec[mid2] == key)",
"            return mid2;",
"",
"        if (key < vec[mid1])",
"            return ternary_search(vec, l, mid1 - 1, key);",
"",
"        else if (key > vec[mid2])",
"            return ternary_search(vec, mid2 + 1, r, key);",
"",
"        return ternary_search(vec, mid1 + 1, mid2 - 1, key);",
"    }",
"",
"    return -1;",
"}",
        ],
        "description": "Log output to console"
    }

    "ternary_search_mx": {
        "prefix": "ternary_search_mx",
        "body": [
"int ternary_search(vector<int> &vec)",
"{",
"    int l = 0, r = vec.size() - 1;",
"    while (r - l > 1)",
"    {",
"        int mid1 = l + (r - l) / 3, mid2 = l + (2 * (r - l)) / 3;",
"        if (vec[mid1] >= vec[mid2])",
"            r = mid2 - 1;",
"",
"        else",
"            l = mid1 + 1;",
"",
"    }",
"",
"    return max(vec[l], vec[r]);",
"}",
        ],
        "description": "Log output to console"
    }

    "ternary_search_mn": {
        "prefix": "ternary_search_mn",
        "body": [
"int ternary_search(vector<int> &vec)",
"{",
"    int l = 0, r = vec.size() - 1;",
"    while (r - l > 1)",
"    {",
"        int mid1 = l + (r - l) / 3, mid2 = l + (2 * (r - l)) / 3;",
"        if (vec[mid1] <= vec[mid2])",
"            r = mid2 - 1;",
"        else",
"            l = mid1 + 1;",
"    }",
"    return min(vec[l], vec[r]);",
"}",
        ],
        "description": "Log output to console"
    }


    "Binary_Search": {
        "prefix": "Binary_Search",
        "body": [
"ll Binary_Search(ll l,ll r,ll key,vector<ll>&vec)",
"{",
"    while(l<=r)",
"    {",
"        ll mid=l+(r-l)/2;",
"",
"        if(vec[mid]==key)return mid;",
"",
"        else if(vec[mid]>key)r=mid-1;",
"",
"        else l=mid+1;",
"    }",
"",
"    return -1;",
"}",
        ],
        "description": "Log output to console"
    }


    "KMP": {
        "prefix": "KMP",
        "body": [
"//Time Complexity O(n+m)",
"vector<int> LPS(string pattern)",
"{",
"    int n = sz(pattern);",
"    vector<int> LPS_arr(n);",
"",
"    for (int i = 1, j = 0; i < n; ++i)",
"    {",
"        while (j > 0 && pattern[i] != pattern[j])",
"            j = LPS_arr[j - 1];",
"        if (pattern[i] == pattern[j])",
"            LPS_arr[i] = ++j;",
"        else",
"            LPS_arr[i] = j;",
"    }",
"",
"    return LPS_arr;",
"}",
"",
"vector<int> KMP(string s, string pattern)",
"{",
"    int n = sz(s);",
"    int m = sz(pattern);",
"    vector<int> ans;",
"    vector<int> LPS_arr = LPS(pattern);",
"",
"    for (int i = 1, j = 0; i < n; ++i)",
"    {",
"        while (j > 0 && pattern[j] != s[i])",
"            j = LPS_arr[j - 1];",
"",
"        if (pattern[j] == s[i])",
"            j++;",
"",
"        if (j == m)",
"        {",
"            ans.eb(i - m + 1);",
"            j = LPS_arr[j - 1];",
"        }",
"",
"    }",
"",
"    return ans;",
"",
"}",
        ],
        "description": "Log output to console"
    }


    "Trie": {
        "prefix": "Trie",
        "body": [
"class Trie",
"{",
"public:",
"    vector<Trie *> child;",
"    bool is_leaf;",
"",
"    Trie()",
"    {",
"        is_leaf = 0;",
"        child.assign(26, NULL);",
"    }",
"",
"    void insert(string word)",
"    {",
"        if (word.empty())",
"            is_leaf = true;",
"",
"        else",
"        {",
"            int cur_node = word.front() - 'a';",
"            if (!child[cur_node])",
"                child[cur_node] = new Trie();",
"            child[cur_node]->insert(word.substr(1));",
"        }",
"",
"    }",
"",
"    bool search(string word)",
"    {",
"        if (word.empty())",
"            return is_leaf;",
"        int cur_node = word.front() - 'a';",
"        if (!child[cur_node])",
"            return false;",
"        return child[cur_node]->search(word.substr(1));",
"    }",
"",
"    bool startsWith(string prefix)",
"    {",
"        if (prefix.empty())",
"            return true;",
"",
"        int cur_node = prefix.front() - 'a';",
"",
"        if (!child[cur_node])",
"            return false;",
"",
"        return child[cur_node]->startsWith(prefix.substr(1));",
"",
"    }",
"",
"};",
        ],
        "description": "Log output to console"
    }



    "mo": {
        "prefix": "mo",
        "body": [
"//mo algorithms for find how many number repeated at least 3 time in some ranges",
"//Time complexity o(n+q)*sqrt(n)",
"",
"//This part of the code is fixed",
"int n,q,result=0;",
"vector<int>vec,ans;",
"map<ll,ll>mp;",
"",
"struct mo",
"{",
"    int l,r,block_idx,q_idx;",
"",
"    mo(){}",
"    mo(int _l,int _r,int _q_idx)",
"    {",
"        l=_l,r=_r,q_idx=_q_idx,block_idx=int(_l/sqrt(n));",
"    }",
"",
"    bool operator <(const mo&rhs) const",
"    {",
"",
"        if(block_idx!=rhs.block_idx)",
"            return block_idx<rhs.block_idx;",
"",
"        return r<rhs.r;",
"    }",
"",
"};",
"",
"//__________________________________________________",
"",
"//We modify this part according to the problem.",
"vector<mo>v;",
"",
"void remove(int idx)",
"{",
"    mp[vec[idx]]--;",
"",
"    if(mp[vec[idx]]==2)",
"        result--;",
"",
"}",
"",
"void add(int idx)",
"{",
"    mp[vec[idx]]++;",
"",
"    if(mp[vec[idx]]==3)",
"        result++;",
"}",
        ],
        "description": "Log output to console"
    }


    "linear_sieve": {
        "prefix": "linear_sieve",
        "body": [
"// time complexity n",
"",
"template <typename T = int>",
"struct linear_sieve",
"{",
"    vector<bool> is_prime;",
"    vector<T> primes;",
"    int n;",
"",
"    linear_sieve(int n)",
"    {",
"        is_prime.assign(n + 5, true);",
"        is_prime[0] = is_prime[1] = false;",
"",
"        for (int i = 2; i < n; ++i)",
"        {",
"            if (is_prime[i])",
"                primes.push_back(i);",
"",
"            for (int j = 0; j < sz(primes) && i * primes[j] < n; ++j)",
"            {",
"                is_prime[i * primes[j]] = false;",
"",
"                if (!(i % primes[j]))",
"                    break;",
"            }",
"        }",
"    }",
"",
"    vector<T> get_primes()",
"    {",
"        return primes;",
"    }",
"",
"};",
        ],
        "description": "Log output to console"
    }

    "segmented_sieve": {
        "prefix": "segmented_sieve",
        "body": [
"// get prime numbers between L R",
"// Time complexity o(R-L+1)*log(log(R))",
"",
"template <typename T>",
"struct segmented_sieve",
"{",
"private:",
"    ll lim;",
"    vector<bool> mark, is_prime;",
"    vector<T> primes;",
"    T L, R;",
"",
"public:",
"    segmented_sieve(T _L, T _R) : L(_L), R(_R)",
"    {",
"        lim = sqrtl(R);",
"        mark.assign(lim + 1, true);",
"",
"        for (T i = 2; i <= lim; ++i)",
"        {",
"            if (mark[i])",
"            {",
"                primes.eb(i);",
"",
"                for (T j = i * i; j <= lim; j += i)",
"                    mark[j] = false;",
"            }",
"        }",
"",
"        is_prime.assign(R - L + 1, true);",
"",
"        for (auto &i : primes) // 2 3",
"            for (T j = max(i * i, ceil(L, i) * i); j <= R; j += i)",
"                is_prime[j - L] = false; // in case L and R are big numbers will subtract all number from L",
"",
"        if (L == 1)",
"            is_prime[0] = false;",
"",
"    };",
"",
"    vector<T> get_primes()",
"    {",
"        vector<T> primes;",
"        for (T i = L; i <= R; ++i)",
"            if (is_prime[i - L])",
"                primes.eb(i);",
"",
"        return primes;",
"    }",
"",
"    vector<bool> get_boolean_primes()",
"    {",
"        return is_prime;",
"    }",
"",
"};",
        ],
        "description": "Log output to console"
    }

    "Sieve_Eratosthenes": {
        "prefix": "Sieve_Eratosthenes",
        "body": [
"// time complexity n log(log(n))",
"",
"template <typename T = int>",
"struct sieve",
"{",
"   vector<bool> is_prime;",
"   vector<T> primes;",
"   int n;",
" ",
"   sieve(int n)",
"   {",
"      this->n = n;",
"      is_prime.assign(n + 5, 1);",
"      is_prime[0] = is_prime[1] = false;",
"",
"      for (int i = 2; i * i <= n; ++i)",
"      {",
"         if (is_prime[i])",
"         {",
"            for (int l = i * i; l <= n; l += i)",
"            {",
"               is_prime[l] = false;",
"            }",
"         }",
"      }",
"   }",
"",
"   vector<bool> GetBooleanArray()",
"   {",
"      return is_prime;",
"   }",
"",
"   vector<T> get_primes()",
"   {",
"      for (int i = 1; i <= n; ++i)",
"         if (is_prime[i])",
"         primes.push_back(i);",
"",
"       return primes;",
"   }",
"};",
        ],
        "description": "Log output to console"
    }



    "Coordinate_Compression": {
        "prefix": "Coordinate_Compression",
        "body": [
"template<typename T=int>struct Coordinate_Compression",
"{",
"private:",
"    vector<T>vec;",
"    bool is_bulid;",
"    void bulid()",
"    {",
"        sort(all(vec));",
"        vec.resize(unique(all(vec))-vec.begin());   ",
"        is_bulid=true;",
"    }",
"",
"public:",
"    Coordinate_Compression(vector<T>&v)",
"    {",
"        vec=v;",
"        bulid();",
"    }",
"",
"    Coordinate_Compression(): is_bulid(false) {}",
"",
"    void add(T val)",
"    {",
"        vec.emplace_back(val);",
"        is_bulid=false;",
"    }",
"",
"    T get_val(T value)",
"    {",
"        if(!is_bulid)bulid();",
"        return upper_bound(all(vec),value)-vec.begin();",
"    }",
"",
"    vector<T> get_compressed_element()",
"    {",
"        if(!is_bulid)bulid();",
"        vector<T>ans;",
"",
"        for(auto&i:vec)",
"            ans.emplace_back(get_val(i));",
"",
"        return ans;",
"    }",
"",
"    vector<T> get_mapping()",
"    {",
"        if(!is_bulid)bulid();",
"        vector<T>ans(sz(vec)+1);",
"",
"        for(auto&i:vec)",
"            ans[get_val(i)]=i;",
"",
"        return ans;",
"    }",
"};",
        ],
        "description": "Log output to console"
    }

    "monotonic_stack": {
        "prefix": "monotonic_stack",
        "body": [
"template<typename T>struct monotonic_stack",
"{",
"private:",
"    vector<T>vec;",
"    vector<T>ans;",
"    int size;",
"",
"public:",
"    monotonic_stack(vector<T>&v):vec(v),size(sz(v))",
"    {",
"        ans=vector<T>(sz(v));",
"    }",
"",
"    vector<T> next_greater_element()",
"    {",
"        stack<T>monotonic;",
"        for(int i=size-1;i>=0;i--)",
"        {",
"            while(!monotonic.empty()&&vec[i]>=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i]=-1;",
"            else ans[i]=monotonic.top();",
"            monotonic.push(i);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> prev_greater_element()",
"    {",
"        stack<T>monotonic;",
"        for(int i=0;i<size;i++)",
"        {",
"            while(!monotonic.empty()&&vec[i]>=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i]=-1;",
"            else ans[i]=monotonic.top();",
"            monotonic.push(i);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> next_smaller_element()",
"    {",
"        stack<T>monotonic;",
"        for(int i=size-1;i>=0;i--)",
"        {",
"            while(!monotonic.empty()&&vec[i]<=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i]=-1;",
"            else ans[i]=monotonic.top();",
"            monotonic.push(i);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> prev_smaller_element()",
"    {",
"        stack<T>monotonic;",
"        for(int i=0;i<size;i++)",
"        {",
"            while(!monotonic.empty()&&vec[i]<=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i]=-1;",
"            else ans[i]=monotonic.top();",
"            monotonic.push(i);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> next_greater_element_in_circular()",
"    {",
"        stack<T>monotonic;",
"        for(int i=(2*size)-1;i>=0;i--)",
"        {",
"            while(!monotonic.empty()&&vec[i%size]>=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i%size]=-1;",
"            else ans[i%size]=monotonic.top();",
"            monotonic.push(i%size);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> prev_greater_element_in_circular()",
"    {",
"        stack<T>monotonic;",
"        for(int i=0;i<2*size;i++)",
"        {",
"            while(!monotonic.empty()&&vec[i%size]>=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i%size]=-1;",
"            else ans[i%size]=monotonic.top();",
"            monotonic.push(i%size);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> next_smaller_element_in_circular()",
"    {",
"        stack<T>monotonic;",
"        for(int i=(2*size)-1;i>=0;i--)",
"        {",
"            while(!monotonic.empty()&&vec[i%size]<=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i%size]=-1;",
"            else ans[i%size]=monotonic.top();",
"            monotonic.push(i%size);",
"        }",
"",
"        return ans;",
"    }",
"",
"    vector<T> prev_smaller_element_in_circular()",
"    {",
"        stack<T>monotonic;",
"        for(int i=0;i<2*size;i++)",
"        {",
"            while(!monotonic.empty()&&vec[i%size]<=vec[monotonic.top()])monotonic.pop();",
"            if(monotonic.empty())ans[i%size]=-1;",
"            else ans[i%size]=monotonic.top();",
"            monotonic.push(i%size);",
"        }",
"",
"        return ans;",
"    }",
"",
"};",
        ],
        "description": "Log output to console"
}
    "segTree": {
        "prefix": "segTree",
        "body": [
"struct SegmentTree{",
"private:",
"#define L 2*node+1",
"#define R 2*node+2",
"#define mid (l+r>>1)",
"    int sz;vector<ll>seg;",
"    void build(int l,int r,int node,vector<ll>&arr){",
"        if(l==r){",
"            if(l<arr.size()){",
"            seg[node]=arr[l];",
"            }",
"            return;",
"        }",
"        build(l,mid,L,arr);",
"        build(mid+1,r,R,arr);",
"        seg[node]=seg[L]+seg[R];",
"    }",
"    void update(int l,int r,int node,int idx,ll val){",
"        if(l==r){",
"            seg[node]=val;",
"            return;",
"        }",
"        if(idx<=mid){",
"            update(l,mid,L,idx,val);",
"        }",
"        else{",
"            update(mid+1,r,R,idx,val);",
"        }",
"        seg[node]=seg[L]+seg[R];",
"    }",
"    ll query(int l,int r,int node,int lq,int rq){",
"        if(r<lq||l>rq){",
"            return 0;",
"        }",
"        if(l>=lq&&r<=rq){",
"            return seg[node];",
"        }",
"        ll lft=query(l,mid,L,lq,rq);",
"        ll rgt=query(mid+1,r,R,lq,rq);",
"        return lft+rgt;",
"    }",
"public:",
"    SegmentTree(vector<ll>&arr){",
"        sz=1;int n=arr.size();",
"        while(sz<n) sz*=2;",
"        seg=vector<ll>(sz*2);",
"        build(0,sz-1,0,arr);",
"    }",
"    void update(int idx,ll val){",
"        update(0,sz-1,0,idx,val);",
"    }",
"    ll query(int l,int r){",
"        return query(0,sz-1,0,l,r);",
"    }",
"#undef L",
"#undef R",
"};",
        ],
        "description": "Log output to console"
    }


    "mInt": {
        "prefix": "mInt",
        "body": [
"template < int MOD = 1000000007, typename T = int > struct ModInt {",
"   T val;",
"   ModInt(T V = 0) : val(V) { val %= MOD; }",
"   ModInt& operator += (const ModInt& rhs) {",
"      if ((val += rhs.val) >= MOD) val -= MOD;",
"      return *this;",
"   }",
"   ModInt& operator += (const T rhs) {",
"      if ((val += rhs) >= MOD) val -= MOD;",
"      return *this;",
"   }",
"   ModInt& operator -= (const ModInt& rhs) { ",
"      if ((val += MOD - rhs.val) >= MOD) val -= MOD; ",
"       return *this; ",
"   }",
"   ModInt& operator -= (const T rhs) { ",
"      if ((val += MOD - rhs) >= MOD) val -= MOD; ",
"      return *this; ",
"   }",
"   ModInt& operator *= (const ModInt& rhs) { val = (1ll * val * rhs.val) % MOD; return *this; }",
"   ModInt& operator *= (const T rhs) { val = (1ll * val * rhs) % MOD; return *this; }",
"   ModInt& operator /= (const ModInt& rhs) { return *this *= rhs.inverse(); }",
"   ModInt& operator /= (const T rhs) { return *this *= ModInt(rhs).inverse(); }",
"   ModInt& operator %= (const ModInt& rhs) { val %= rhs.val; return *this; }",
"   ModInt& operator %= (const T rhs) { val %= rhs; return *this; }",
"   ModInt& operator ++() { return *this += 1; }",
"   ModInt& operator --() { return *this -= 1; }",
"   ModInt operator ++(T unused) { ModInt res(*this); ++*this; return res; }",
"   ModInt operator --(T unused) { ModInt res(*this); --*this; return res; }",
"   ModInt operator + (const ModInt& rhs) const { ModInt res(*this); return res += rhs; }",
"   ModInt operator + (const T rhs) const { ModInt res(*this); return res += rhs; }",
"   ModInt operator % (const ModInt& rhs) const { ModInt res(*this); return res %= rhs; }",
"   ModInt operator % (const T rhs) const { ModInt res(*this); return res %= rhs; }",
"   ModInt operator - (const ModInt& rhs) const { ModInt res(*this); return res -= rhs; }",
"   ModInt operator - (const T rhs) const { ModInt res(*this); return res -= rhs; }",
"   ModInt operator * (const ModInt& rhs) const { ModInt res(*this); return res *= rhs; }",
"   ModInt operator * (const T rhs) const { ModInt res(*this); return res *= rhs; }",
"   ModInt operator / (const ModInt& rhs) const { ModInt res(*this); return res /= rhs; }",
"   ModInt operator / (const T rhs) const { ModInt res(*this); return res /= rhs; }",
"   ModInt& operator = (const ModInt& rhs) { val = rhs.val; return *this; }",
"   ModInt& operator = (const T rhs) { val = rhs; return *this; }",
"   T operator ~ () { return ~val; }",
"   bool operator ! () { return !val; }",
"   bool operator == (const ModInt& rhs) const { return val == rhs.val; }",
"   bool operator == (const T rhs) const { return val == rhs; }",
"   bool operator != (const ModInt& rhs) const { return val != rhs.val; }",
"   bool operator != (const T rhs) const { return val != rhs; }",
"   bool operator < (const ModInt& rhs) const { return val < rhs.val; }",
"   bool operator < (const T rhs) const { return val < rhs; }",
"   bool operator <= (const ModInt& rhs) const { return val <= rhs.val; }",
"   bool operator <= (const T rhs) const { return val <= rhs; }",
"   bool operator > (const ModInt& rhs) const { return val > rhs.val; }",
"   bool operator > (const T rhs) const { return val > rhs; }",
"   bool operator >= (const ModInt& rhs) const { return val >= rhs.val; }",
"   bool operator >= (const T rhs) const { return val >= rhs; }",
"   T operator () () const { return val; }",
"   ModInt inverse() const { return power(MOD - 2); }",
"   ModInt power(T n) const {",
"   ModInt a = *this, res = 1;",
"      while (n > 0) {",
"         if (n & 1) res *= a;",
"         a *= a, n >>= 1;",
"      }",
"      return res;",
"   }",
"   ModInt power(ModInt n) const {",
"      ModInt a = *this, res = 1;",
"      T e = n();",
"      while (e > 0) {",
"         if (e & 1) res *= a;",
"         a *= a, e >>= 1;",
"      }",
"      return res;",
"   }",
"   friend ModInt operator ^ (ModInt rhs, T n) { return rhs.power(n); }",
"   friend ModInt operator ^ (ModInt rhs, ModInt n) { return rhs.power(n); }",
"   friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }",
"   friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }",
"};",
"using Mint = ModInt < 998244353 >;",
],
"description": "Log output to console"
}

}


/*
    "kadane2dmx": {
        "prefix": "kadane2dmx",
        "body": [
            
        ],
        "description": "Log output to console"
    }
*/
